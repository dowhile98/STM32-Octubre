/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include "defines.h"
#include "delay.h"
/*Deefines -----------------------------------------*/
#define GPIOD_ODR_OFFSET	(GPIOD_BASE + 0x14)
#define BITBAND_PERI(a, b) ((PERIPH_BB_BASE + (a - PERIPH_BASE) * 32 + 4 * b))

#define ODRD_BIT12   		*((volatile uint8_t*)BITBAND_PERI(GPIOD_ODR_OFFSET, 12))

#define PORT(P)		GPIO ## P // GPIOA->ODR

#define PIN_SET(a, b) GPIO ## a ->ODR |= 1U<< b

#define LED 		D, 12

#define LED_ON_(a, b) GPIO ## a -> ODR |= 1U<<b
#define LED_ON(a)     LED_ON_(a)

#define LED_OFF_(a, b) GPIO ## a -> ODR &=~ (1<<b)
#define LED_OFF(a)	  LED_OFF_(a)

#define LED_RED 	D, 13
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);


int main(void)
{
	PLL_Config();

	delay_init();
	//1. habilitar el reloj
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIODEN;
	//PD12->SALIDA
	GPIOD->MODER &=~ (GPIO_MODER_MODE12);		//Clear (reset state)
	GPIOD->MODER |= GPIO_MODER_MODE12_0;			//salida de proposito general
	GPIOD->OTYPER &=~ GPIO_OTYPER_OT12;			//salida push pull
	GPIOD->OSPEEDR |= GPIO_OSPEEDR_OSPEED12;		//very high speed
	GPIOD->PUPDR &=~ GPIO_PUPDR_PUPD12;			//No pull up / down
	//PA0->ENTRADA
	GPIOA->MODER &=~ GPIO_MODER_MODE0;			//input (reset state)

	ODRD_BIT12 = 1;

	ODRD_BIT12 = 0;


	ODRD_BIT12 = 1;

	ODRD_BIT12 = 0;

	PORT(A)->ODR |= 1<<12;

	PIN_SET(D, 12);

	LED_OFF(LED);
	LED_ON(LED);
	LED_OFF(LED);

	//->CON LOS DEFINES
	RCC->AHB1ENR |= GPIOX_CLOCK(LED_RED);
	GPIOX_MODER(MODE_OUT, LED_RED);
	GPIOX_OTYPER(MODE_OT_PP, LED_RED);
	GPIOX_OSPEEDR(MODE_SPD_VHIGH, LED_RED);
	GPIOX_PUPDR(MODE_PU_NONE, LED_RED);
	/* Loop forever */
	for(;;){
		GPIOX_ODR(LED) ^= 1;
		delay_ms(100);
	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}

/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
