/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include <defines.h>
/*Defines -------------------------------------------------*/
#define ADC1_IN1	A, 1 //PA1
/*Global variables ----------------------------------------*/

/*Function prototype --------------------------------------*/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

void TIM2_Config(uint32_t freq);

int main(void)
{

	//printf("SYSCLK ANTES DE CONFIGURAR EL PLL: %lu\r\n",SystemCoreClock);
	PLL_Config();
	/* Loop forever */
	//->PA1 como analogico
	RCC->AHB1ENR |= GPIOX_CLOCK(ADC1_IN1);
	GPIOX_MODER(MODE_ANALOG_INPUT, ADC1_IN1);
	GPIOX_PUPDR(MODE_PU_NONE, ADC1_IN1);
	//->ADC1
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;		//habilita el reloj para poder acceder a los registros del adc
	ADC123_COMMON->CCR &=~ ADC_CCR_ADCPRE;
	ADC123_COMMON->CCR |= ADC_CCR_ADCPRE_0; //hace un prescaler de 4 -> 84 / 4 -> 21MHZ

	//DISPARO
	ADC1->CR2 = 0x6U<<ADC_CR2_EXTSEL_Pos;	//seleccionamos el TIMER2 salida TRGO para disparo de conversion ADC
	ADC1->CR2 |= ADC_CR2_EXTEN_0;			//Disparo por flanco acendente
	//RESOLUCION
	ADC1->CR1 = 0;							//12BITS

	//interupcion
	ADC1->CR1 |= ADC_CR1_EOCIE;
	NVIC_EnableIRQ(ADC_IRQn);

	//CONFIGURACION DEL TIMER
	TIM2_Config(1);

	//CONFIGURACION INDEPENDIENTE DEL CANAL
	ADC1->SMPR2 &=~ ADC_SMPR2_SMP1; 		//tiempo de muestro 3 ciclos

	//cantidad de conversiones
	ADC1->SQR1 &=~ ADC_SQR1_L;				//Una sola conversion
	//la secuencia de conversion
	ADC1->SQR3 &=~ ADC_SQR3_SQ1;
	ADC1->SQR3 |= 1<<ADC_SQR3_SQ1_Pos;
	//Habilitar el ADC
	ADC1->CR2 |= ADC_CR2_ADON;

	for(;;){

	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}

void TIM2_Config(uint32_t freq){
	uint32_t arr;
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	/*Configura el PSC y ARR*/
	/**
	 * update event = Ftim/(PSC + 1)*(ARR + 1)
	 * PSC = 0;
	 * ARR = 84MHZ/(freq) - 1:
	 */
	arr = (84E+6)/(freq) - 1;
	TIM2->ARR = arr;
	TIM2->PSC = 0;

	//habilitar la salida TRGO para disparar al conversion adc
	TIM2->CR2 &=~ TIM_CR2_MMS;
	TIM2->CR2 |= TIM_CR2_MMS_1;		//habilita el TGRO para el disparo del adc

	TIM2->CR1 |= TIM_CR1_CEN;
	return;
}
/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
