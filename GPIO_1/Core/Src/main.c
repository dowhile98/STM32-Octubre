/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>

/**
 * ## -> REPASAR
 * #define USART_MODBUS huart1
 * #define MODUBUS      1
 */
typedef struct{
	volatile uint8_t b0:1;
	volatile uint8_t b1:1;
	volatile uint8_t b2:1;
	volatile uint8_t b3:1;
	volatile uint8_t b4:1;
	volatile uint8_t b5:1;
	volatile uint8_t b6:1;
	volatile uint8_t b7:1;
	volatile uint8_t b8:1;
	volatile uint8_t b9:1;
	volatile uint8_t b10:1;
	volatile uint8_t b11:1;
	volatile uint8_t b12:1;
	volatile uint8_t b13:1;
	volatile uint8_t b14:1;
	volatile uint8_t b15:1;
}Port_bits_t;

/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

void delay_ms(uint32_t delay){
	uint32_t temp = SystemCoreClock / 1000 - 1;
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk;
	SysTick->LOAD = temp;
	SysTick->VAL = 0;
	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
	for(uint32_t i = 0; i<delay; i++){
		while(!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk));
	}
	SysTick->CTRL &=~ SysTick_CTRL_ENABLE_Msk;

	return;
}

int main(void)
{
	Port_bits_t *ODRD = (Port_bits_t *) &GPIOD->ODR;
	Port_bits_t *IDRA = (Port_bits_t *) &GPIOA->IDR;
	char str[30];
	PLL_Config();
	//1. habilitar el reloj
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIODEN;
	//PD12->SALIDA
	GPIOD->MODER &=~ (GPIO_MODER_MODE12);		//Clear (reset state)
	GPIOD->MODER |= GPIO_MODER_MODE12_0;			//salida de proposito general
	GPIOD->OTYPER &=~ GPIO_OTYPER_OT12;			//salida push pull
	GPIOD->OSPEEDR |= GPIO_OSPEEDR_OSPEED12;		//very high speed
	GPIOD->PUPDR &=~ GPIO_PUPDR_PUPD12;			//No pull up / down
	//PA0->ENTRADA
	GPIOA->MODER &=~ GPIO_MODER_MODE0;			//input (reset state)

	/* Loop forever */
	for(;;){
		sprintf(str, "LED->%s\r\n", (GPIOD->IDR & GPIO_IDR_ID12)? "ON" : "OFF");

		printf("%s", str);
		//GPIOD->ODR ^= GPIO_ODR_OD12;
		//GPIOD->BSRR |= GPIO_BSRR_BS12;

		ODRD->b12 = 1;
		delay_ms(500);
		//GPIOD->BSRR |= GPIO_BSRR_BR12;
		ODRD->b12 = 0;
		delay_ms(500);
		//LEER
		//uint8_t bit = GPIOA->IDR>>0 & 0x1U;
		uint8_t bit = IDRA->b0;
		printf("PA0->%d", bit);
	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}

/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
