/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes -------------------------------------------------------*/
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "delay.h"
#include "defines.h"
#include "ST7735.h"
#include "lv_driver.h"
#include "lvgl.h"
#include "gfx.h"
/*Macro defines --------------------------------------------------*/
/**
 * @brief para seleccionar el medio de transmision para el printf
 * 0: USART
 * 1: SW0
 */
#define USE_SW0			1

#define SPI1_MOSI		A, 7
#define SPI1_SCK		A, 5

/*Global variables -----------------------------------------------*/

/*Function prototypes --------------------------------------------*/
void GPIO_Init(void);
void SPI_Init(SPI_TypeDef *SPIx);
void DMA2_Stream5_Init(void);

static lv_obj_t * chart1;
static lv_chart_series_t * ser1;
static lv_chart_series_t * ser2;

static void draw_event_cb(lv_event_t * e)
{
    lv_obj_t * obj = lv_event_get_target(e);

    /*Add the faded area before the lines are drawn*/
    lv_obj_draw_part_dsc_t * dsc = lv_event_get_draw_part_dsc(e);
    if(dsc->part == LV_PART_ITEMS) {
        if(!dsc->p1 || !dsc->p2) return;

        /*Add a line mask that keeps the area below the line*/
        lv_draw_mask_line_param_t line_mask_param;
        lv_draw_mask_line_points_init(&line_mask_param, dsc->p1->x, dsc->p1->y, dsc->p2->x, dsc->p2->y,
                                      LV_DRAW_MASK_LINE_SIDE_BOTTOM);
        int16_t line_mask_id = lv_draw_mask_add(&line_mask_param, NULL);

        /*Add a fade effect: transparent bottom covering top*/
        lv_coord_t h = lv_obj_get_height(obj);
        lv_draw_mask_fade_param_t fade_mask_param;
        lv_draw_mask_fade_init(&fade_mask_param, &obj->coords, LV_OPA_COVER, obj->coords.y1 + h / 8, LV_OPA_TRANSP,
                               obj->coords.y2);
        int16_t fade_mask_id = lv_draw_mask_add(&fade_mask_param, NULL);

        /*Draw a rectangle that will be affected by the mask*/
        lv_draw_rect_dsc_t draw_rect_dsc;
        lv_draw_rect_dsc_init(&draw_rect_dsc);
        draw_rect_dsc.bg_opa = LV_OPA_20;
        draw_rect_dsc.bg_color = dsc->line_dsc->color;

        lv_area_t a;
        a.x1 = dsc->p1->x;
        a.x2 = dsc->p2->x - 1;
        a.y1 = LV_MIN(dsc->p1->y, dsc->p2->y);
        a.y2 = obj->coords.y2;
        lv_draw_rect(dsc->draw_ctx, &draw_rect_dsc, &a);

        /*Remove the masks*/
        lv_draw_mask_free_param(&line_mask_param);
        lv_draw_mask_free_param(&fade_mask_param);
        lv_draw_mask_remove_id(line_mask_id);
        lv_draw_mask_remove_id(fade_mask_id);
    }
    /*Hook the division lines too*/
    else if(dsc->part == LV_PART_MAIN) {
        if(dsc->line_dsc == NULL || dsc->p1 == NULL || dsc->p2 == NULL) return;

        /*Vertical line*/
        if(dsc->p1->x == dsc->p2->x) {
            dsc->line_dsc->color  = lv_palette_lighten(LV_PALETTE_GREY, 1);
            if(dsc->id == 3) {
                dsc->line_dsc->width  = 2;
                dsc->line_dsc->dash_gap  = 0;
                dsc->line_dsc->dash_width  = 0;
            }
            else {
                dsc->line_dsc->width = 1;
                dsc->line_dsc->dash_gap  = 6;
                dsc->line_dsc->dash_width  = 6;
            }
        }
        /*Horizontal line*/
        else {
            if(dsc->id == 2) {
                dsc->line_dsc->width  = 2;
                dsc->line_dsc->dash_gap  = 0;
                dsc->line_dsc->dash_width  = 0;
            }
            else {
                dsc->line_dsc->width = 2;
                dsc->line_dsc->dash_gap  = 6;
                dsc->line_dsc->dash_width  = 6;
            }

            if(dsc->id == 1  || dsc->id == 3) {
                dsc->line_dsc->color  = lv_palette_main(LV_PALETTE_GREEN);
            }
            else {
                dsc->line_dsc->color  = lv_palette_lighten(LV_PALETTE_GREY, 1);
            }
        }
    }
}

static void add_data(lv_timer_t * timer)
{
    LV_UNUSED(timer);
    static uint32_t cnt = 0;
    lv_chart_set_next_value(chart1, ser1, lv_rand(20, 90));

    if(cnt % 4 == 0) lv_chart_set_next_value(chart1, ser2, lv_rand(40, 60));

    cnt++;
}

/**
 * Add a faded area effect to the line chart and make some division lines ticker
 */
void lv_example_chart_2(void)
{
    /*Create a chart1*/
    chart1 = lv_chart_create(lv_scr_act());
    lv_obj_set_size(chart1, 200, 150);
    lv_obj_center(chart1);
    lv_chart_set_type(chart1, LV_CHART_TYPE_LINE);   /*Show lines and points too*/

    lv_chart_set_div_line_count(chart1, 5, 7);

    lv_obj_add_event_cb(chart1, draw_event_cb, LV_EVENT_DRAW_PART_BEGIN, NULL);
    lv_chart_set_update_mode(chart1, LV_CHART_UPDATE_MODE_CIRCULAR);

    /*Add two data series*/
    ser1 = lv_chart_add_series(chart1, lv_palette_main(LV_PALETTE_RED), LV_CHART_AXIS_PRIMARY_Y);
    ser2 = lv_chart_add_series(chart1, lv_palette_main(LV_PALETTE_BLUE), LV_CHART_AXIS_SECONDARY_Y);

    uint32_t i;
    for(i = 0; i < 10; i++) {
        lv_chart_set_next_value(chart1, ser1, lv_rand(20, 90));
        lv_chart_set_next_value(chart1, ser2, lv_rand(30, 70));
    }

    lv_timer_create(add_data, 200, NULL);
}


int main(void)
{
	RCC->AHB1ENR |= GPIOX_CLOCK(LED);
	GPIOX_MODER(MODE_OUT, LED);
	
	//delay init
	delay_init();
	//peripheral int
	GPIO_Init();
	DMA2_Stream5_Init();
	SPI_Init(SPI1);
	LCD_initDisplay(INITR_BLACKTAB);
	LCD_setRotation(1);
	  LCD_setRotation(0);

	  GFX_fillCircle(50, 50, 30, BLUE);
	  LCD_Delay(1000);
	  GFX_fillScreen(ST77XX_RED);
	  GFX_fillCircle(50, 50, 30, YELLOW);
	  LCD_Delay(1000);
	  LCD_setRotation(1);
	  GFX_fillRect(0, 0, 50, 40, BLACK);
	  LCD_Delay(1000);
	  LCD_setRotation(2);
	  GFX_fillRect(0, 0, 50, 40, MAGENTA);
	//TFT
//	lv_init();
//	lv_port_disp_init();
//	lv_example_chart_2();
    /* Loop forever */
	for(;;){
//		lv_tick_inc(1);
//		lv_task_handler();
		delay_ms(1);
	}
}
/*Function definition ------------------------------------------------*/
void GPIO_Init(void){
	RCC->AHB1ENR |= GPIOX_CLOCK(SPI1_SCK) | GPIOX_CLOCK(SPI1_MOSI);
	    RCC->AHB1ENR |= GPIOX_CLOCK(A0) | GPIOX_CLOCK(CS) | GPIOX_CLOCK(RESET);
	    //Salida
	    GPIOX_MODER(MODE_OUT, A0);
	    GPIOX_MODER(MODE_OUT, RESET);
	    GPIOX_MODER(MODE_OUT, CS);
	    GPIOX_OSPEEDR(MODE_SPD_VHIGH, A0);
	    GPIOX_OSPEEDR(MODE_SPD_VHIGH, RESET);
	    GPIOX_OSPEEDR(MODE_SPD_VHIGH, CS);
	    //SPI3
	    GPIOX_MODER(MODE_ALTER, SPI1_SCK);
	    GPIOX_MODER(MODE_ALTER, SPI1_MOSI);
	    GPIOX_AFR(5, SPI1_SCK);
	    GPIOX_AFR(5, SPI1_MOSI);
	    GPIOX_OSPEEDR(MODE_SPD_VHIGH, SPI1_MOSI);
	    GPIOX_OSPEEDR(MODE_SPD_VHIGH, SPI1_SCK);
	return;
}
void SPI_Init(SPI_TypeDef *SPIx){
	/*enable clock*/
	if(SPIx == SPI1)
		RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
	else if(SPIx == SPI2)
		RCC->APB1ENR |= RCC_APB1ENR_SPI2EN;
	else
		RCC->APB1ENR |= RCC_APB1ENR_SPI3EN;

/******************************************************************************/
	//1. Configurar el baudrate
	SPIx->CR1 &=~ SPI_CR1_BR;			//Fpclk / 2 = 8MHz
	SPIx->CR1 |= SPI_CR1_BR_0;			//Fpclk / 4 = 4MHz
	//2. configurar la poliridad y la fasse del reloj
	//CPOL
	SPIx->CR1 &=~ SPI_CR1_CPOL;			//CPOL = 0
	//CPHA
	SPIx->CR1 &=~ SPI_CR1_CPHA;			//CPHA = 0
	/*3. seleccionar la longitud de la trama*/
	SPIx->CR1 &=~ SPI_CR1_DFF;			//8-bit
	/*4. configurar LSB o MSB first*/
	SPIx->CR1 &=~ SPI_CR1_LSBFIRST;		//MSB FIRST
	/*5. configura el mamejo del pin NSS*/
	SPIx->CR1 |= SPI_CR1_SSM;			//software managment
	SPIx->CR1 |= SPI_CR1_SSI;
	/*6 configurar el modo TI si es que fuera necesario	 */

	/*7. habilita el modo maestro*/
	SPIx->CR1 |= SPI_CR1_MSTR;			//habilita el modo maestro
	/*8. habilitar el spi*/
	SPIx->CR1 |= SPI_CR1_SPE;			//habilita el spi para tx y rx
}
void DMA2_Stream5_Init(void){
	//se habilita el reloj
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
    //se habilita la interrupcion para el stream5
    NVIC_EnableIRQ(DMA2_Stream5_IRQn);
    //se selecciona el canal
    DMA2_Stream5->CR &=~ DMA_SxCR_CHSEL;            //channel 0
	DMA2_Stream5->CR |= DMA_SxCR_CHSEL_1 | DMA_SxCR_CHSEL_0;	//channel 3
    //se establece la direccion
    DMA2_Stream5->CR &=~ DMA_SxCR_DIR;
    DMA2_Stream5->CR |= DMA_SxCR_DIR_0;
    //prioridad alta
    DMA2_Stream5->CR |= DMA_SxCR_PL;                //prioridad alta
    //modo normal
    DMA2_Stream5->CR &=~ DMA_SxCR_CIRC;
    DMA2_Stream5->CR &=~ DMA_SxCR_PFCTRL;
    //increment
    DMA2_Stream5->CR |= DMA_SxCR_MINC;
    DMA2_Stream5->CR &=~ DMA_SxCR_PINC;
    //tamaÃ±o de datos
    DMA2_Stream5->CR &=~ DMA_SxCR_PSIZE;
    DMA2_Stream5->FCR &=~ DMA_SxFCR_DMDIS;
	return ;
}
/**********************************************************************/

int __io_putchar(int ch){
#if (USE_SW0 == 1)
	ITM_SendChar(ch);
#else
	//todo

#endif
	return ch;
}
