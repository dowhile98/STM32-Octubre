/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
/* Private includes ----------------------------------------------------------*/
#include "RCC.h"
#include "Config.h"
#include "Delay.h"
#include "USART.h"
#include <stdio.h>
/* Private typedef -----------------------------------------------------------*/


/* Private define ------------------------------------------------------------*/
#define ADC_CH0			0
#define ADC_CH1			1
#define ADC_CH2			2
#define ADC_CH3			3
#define ADC_CH4			4
#define ADC_CH5			5
#define ADC_CH6			6
#define ADC_CH7			7
#define ADC_CH8			8
#define ADC_CH9			9
#define ADC_CH10		10
#define ADC_CH11		11
#define ADC_CH12		12
#define ADC_CH13		13
#define ADC_CH14		14
#define ADC_CH15		15
/* Private macro -------------------------------------------------------------*/
/**
 * USE_SWV = 1 : el printf se usa para el la depuracion
 * USE_SWV = 0 : el printf se usa para el USART2
 */
#define USE_SWV			0
/* Private variables ---------------------------------------------------------*/

/* Private function prototypes -----------------------------------------------*/
/**
 * @brief configuracion del ADC1
 */
void ADC1_InitScanMode(void);
/**
 * @brief configuracion de canales
 */
void ADC1_ChanelConfiguration(void);
/**
 * @brief lectura de un canal analogico
 */
uint16_t ADC1_ChannelRead(uint8_t chx);

/**
 * @brief cofiguurar el timer2 para generar base de tiempo
 */
void TIM2_Config(uint32_t freq);

/**
 * @brief configua el stream 4 para transferencia periferico a memoria
 */
void DMA2_Stream4Config(void);
/* Private user code ---------------------------------------------------------*/

uint16_t data;

uint16_t adcData[6];
uint8_t i = 0;
uint8_t endConversion  = 0;

float volt;
/* External variables --------------------------------------------------------*/


int main(void)
{
	/*delay Init*/
#if USE_DELAY_US == 1
	delay_Init(SystemCoreClock/1000000);
#else
	delay_Init(SystemCoreClock/1000);
#endif
	/*USART2 init*/
	USART_Init(USART2, 115200);
	/*DMA STREAM 4 INIT*/
	DMA2_Stream4Config();
	/*ADC1 Configuratarion*/
	ADC1_InitScanMode();
	ADC1_ChanelConfiguration();
	//ADC1->CR2 |= ADC_CR2_SWSTART;
	TIM2_Config(10);



	RCC->AHB1ENR |= GPIOX_CLOCK(LED);
	GPIOX_MODER(MODE_OUT,LED);

    /* Loop forever */
	for(;;){
		if(endConversion){
			endConversion = 0;
			GPIOA->ODR ^= 1U<<5;
			printf("ADC_CH0->%u\r\n",adcData[0]);
			printf("ADC_CH1->%u\r\n",adcData[1]);
			printf("ADC_CH4->%u\r\n",adcData[2]);
			printf("ADC_CH8->%u\r\n",adcData[3]);
			printf("ADC_CH11->%u\r\n",adcData[4]);
			printf("ADC_CH10->%u\r\n",adcData[5]);


		}

	}
}
/******************************************************************************/

/**
 * @brief configuracion del ADC1
 */
void ADC1_InitScanMode(void){
	/*habilitar el reloj*/
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;
	/*configurar el ADC*/
	ADC1_COMMON->CCR &=~ADC_CCR_ADCPRE;		//PCLK2 / 2 = 8MHZ
	ADC1->CR1 = 0;
	ADC1->CR2 = 0;
	ADC1->CR1 |= ADC_CR1_SCAN;				//habilita el modo scan

	/*secuencia y la cantidad de conversiones*/
	ADC1->SQR1 |= 5U<<ADC_SQR1_L_Pos;		//6 conversiones
	ADC1->SQR3 |= ADC_CH0;					//1ra conversion
	ADC1->SQR3 |= ADC_CH1<<ADC_SQR3_SQ2_Pos;//2da conversion
	ADC1->SQR3 |= ADC_CH4<<ADC_SQR3_SQ3_Pos;//3ra conversion
	ADC1->SQR3 |= ADC_CH8<<ADC_SQR3_SQ4_Pos;//4ta conversion
	ADC1->SQR3 |= ADC_CH11<<ADC_SQR3_SQ5_Pos;//5ta conversion
	ADC1->SQR3 |= ADC_CH10<<ADC_SQR3_SQ6_Pos;//6ta conversion
	/*configurar el triger externo*/
	ADC1->CR2 |= ADC_CR2_EXTEN_0;			//disparo externo con flanco ascendente
	ADC1->CR2 |= 0x6U<<ADC_CR2_EXTSEL_Pos;	//Timer2 TRIGO event (Update event)
	/*interrupciones*/
	/*DMA REQUEST*/
	ADC1->CR2 |=  1U<<10;
	ADC1->CR2 |= ADC_CR2_DDS;
	ADC1->CR2 |= ADC_CR2_DMA;				//DMA REQUEST FOR HW
	/*encender el ADC*/
	ADC1->CR2 |= ADC_CR2_ADON;
	return;
}
/**
 * @brief configuracion de canales
 */
void ADC1_ChanelConfiguration(void){
	/*PA0->CH0, PA1->CH1, PA4->CH4, PB0->CH8, PC1->CH11, PC0->CH10*/
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOBEN | RCC_AHB1ENR_GPIOCEN;
	//PA0, PA1 y PA4
	GPIOA->MODER |= GPIO_MODER_MODER0 | GPIO_MODER_MODER1 | GPIO_MODER_MODER4;
	GPIOA->PUPDR &=~(GPIO_PUPDR_PUPD0 | GPIO_PUPDR_PUPD1 | GPIO_PUPDR_PUPD4);
	//PB0
	GPIOB->MODER |= GPIO_MODER_MODE0;
	GPIOB->PUPDR &=~(GPIO_PUPDR_PUPD0);
	//PC0, PC1
	GPIOC->MODER |= GPIO_MODER_MODE0 | GPIO_MODER_MODE1;
	GPIOC->PUPDR &=~(GPIO_PUPDR_PUPD0 | GPIO_PUPDR_PUPD1);
	/*SAMPLING TIME*/
	ADC1->SMPR2 |= ADC_SMPR2_SMP1_0;						//15 Cycles
	ADC1->SMPR1 |= ADC_SMPR1_SMP11_1 | ADC_SMPR1_SMP11_0;	//56 Cycles

	return;
}

/**
 * @brief cofiguurar el timer2 para generar base de tiempo
 */
void TIM2_Config(uint32_t freq){
	uint32_t arr;
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	/*Configura el PSC y ARR*/
	/**
	 * update event = Ftim/(PSC + 1)*(ARR + 1)
	 * PSC = 0;
	 * ARR = 16MHZ/(freq) - 1:
	 */
	arr = SystemCoreClock/freq - 1;

	TIM2->PSC = 0;
	TIM2->ARR = arr;
	TIM2->CR2 &=~ TIM_CR2_MMS;
	TIM2->CR2 |= TIM_CR2_MMS_1;		//updata event como salida TRGO
	TIM2->CR1 |= TIM_CR1_CEN;		//habilita el conteo
	return;
}

/******************************************************************************/


/**
 * @brief configua el stream 4 para transferencia periferico a memoria
 */
void DMA2_Stream4Config(void){
	/*habilitar el reloj*/
	RCC->AHB1ENR |= RCC_AHB1ENR_DMA2EN;
	/*1. deshabilitar el stream*/
	DMA2_Stream4->CR &=~ DMA_SxCR_EN;		//reset
	while(DMA2_Stream4->CR & DMA_SxCR_EN);	//WAIT
	DMA2->HIFCR |= 0xF<<2 | 1U;				//clear para el stream 4
	/*2. seleccionar el SxPAR*/
	//DMA2_Stream4->PAR = (uint32_t)(0x40012000 + 0x4C);
	DMA2_Stream4->PAR = (uint32_t)&(ADC1->DR);
	/*3. selecionar el SxMAR*/
	DMA2_Stream4->M0AR = (uint32_t)adcData;
	/*4. Configurar el umero de datos a ser transferido*/
	DMA2_Stream4->NDTR = 6;
	/*5. Seleccionar el canal DMA*/
	DMA2_Stream4->CR &=~ DMA_SxCR_CHSEL;	//Se selecciona el channel 0
	/*6. */

	/*7. Configurar la prioridad del stream*/
	DMA2_Stream4->CR |= DMA_SxCR_PL;		//very high priority
	/*8. Configurar la FIFO*/
	DMA2_Stream4->FCR &=~ DMA_SxFCR_DMDIS;	//direct mode
	/*9. Configuracion del modo de transferencia, tamaÃ±o de datos, modo circular etc*/
	DMA2_Stream4->CR &=~ DMA_SxCR_MSIZE;
	DMA2_Stream4->CR |= DMA_SxCR_MSIZE_0;	//HALF-WORD (16BIT)
	DMA2_Stream4->CR &=~ DMA_SxCR_PSIZE;
	DMA2_Stream4->CR |= DMA_SxCR_PSIZE_0;	//HALF-WORD (16BIT)
	DMA2_Stream4->CR |= DMA_SxCR_MINC;		//memory increment mode
	DMA2_Stream4->CR |= DMA_SxCR_CIRC;		//modo circular
	/*10. configurar la interrupciones*/
	DMA2_Stream4->CR |= 1U<<4 | 1U<<3 | 1U<<2 | 1U<<1;
	NVIC_EnableIRQ(DMA2_Stream4_IRQn);
	DMA2_Stream4->FCR &=~ (DMA_SxFCR_FTH);
	//habilita el estream
	DMA2_Stream4->CR |= DMA_SxCR_EN;		//SE HABILITA EL STREAM

}
/******************************************************************************/
void DMA_TrnsmitCpltCallback(void){
	endConversion = 1;
	return;
}
void DMA_HalfTransmitCpltCallback(void){

	return;
}

/******************************************************************************/
int __io_putchar(int ch){
#if (USE_SWV== 1)
	ITM_SendChar((uint32_t)ch);
#else
	uint8_t c = ch & 0xFF;
	while(!(USART2->SR & USART_SR_TXE));  //espera hasta que usart este listo para transmitir otro byte
	USART2->DR = c;
#endif
	return ch;
}
