/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes -------------------------------------------------------*/
#include <stdint.h>
#include <stdio.h>
#include "stm32f4xx.h"
#include "delay.h"
#include "defines.h"
#include "lvgl.h"
#include "oled_lv_drv.h"
/*Macro defines --------------------------------------------------*/
/**
 *
 * @brief para seleccionar el medio de transmision para el printf
 * 0: USART
 * 1: SW0
 */
#define USE_SW0			1
#define SLAVE_ADDR  	0x69
#define I2C1_SCL		B, 8
#define I2C1_SDA		B, 9

/*Global variables -----------------------------------------------*/

/*Function prototypes --------------------------------------------*/
void I2C1_GPIOInit(void);

void I2C1_Init(void);

/**
 * @funcion de envio de datos
 */
void I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t SlaveAddr,uint8_t *pTxbuffer, uint32_t Len);

/**
 * @brief funcion de recepcion de datos
 */
void I2C_MasterReceiveData(I2C_TypeDef *I2Cx,uint8_t SlaveAddr,uint8_t *pRxbuffer, uint32_t Len);




int main(void)
{
	delay_init();
	//LED
	RCC->AHB1ENR |= GPIOX_CLOCK(LED);
	GPIOX_MODER(MODE_OUT, LED);
	//delay init
	I2C1_GPIOInit();
	I2C1_Init();
	//LVGL
	lv_init();
	lvgl_driver_init();


	lv_obj_t *scr = lv_disp_get_scr_act(disp);
	lv_obj_t *label = lv_label_create(scr);
	lv_label_set_long_mode(label, LV_LABEL_LONG_SCROLL_CIRCULAR); /* Circular scroll */
	lv_label_set_text(label, "HOLA MUNDO DESDE STM32 - LVGL");
	lv_obj_set_width(label, 128);
	lv_obj_align(label, LV_ALIGN_CENTER, 0, 0);
    /* Loop forever */
	for(;;){
		lv_task_handler();
		lv_tick_inc(1);
		delay_ms(1);
	}
}
/*Function definition ------------------------------------------------*/
void I2C1_GPIOInit(void){
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL) | GPIOX_CLOCK(I2C1_SDA);
	//CONFIGURAMOS LOS PINES
	GPIOX_MODER(MODE_ALTER, I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SDA);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SDA);
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SCL);
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SDA);
	GPIOX_AFR(4, I2C1_SCL);
	GPIOX_AFR(4, I2C1_SDA);
	return;
}

void I2C1_Init(void){
	uint32_t tempreg = 0;
	uint16_t ccr_value = 0;
	//ENABLE CLK
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	//reset
	I2C1->CR1 |= 1U<<15;
	delay_ms(1);
	I2C1->CR1 &=~ (1u<<15);
	//configurar los parametros del i2c
	I2C1->CR1 = I2C_CR1_ACK;
	//configurar el campo FREQ cr2
	tempreg = SystemCoreClock / 1000000;
	I2C1->CR2 = (tempreg & 0x3Fu);
	//configurar la direccion esclava del i2c1
	tempreg = SLAVE_ADDR<<1;
	tempreg |= 1u<<14;
	I2C1->OAR1 = tempreg;
	//calculo de CCR
	/**
	 * 400khz
	 */
	tempreg = I2C_CCR_FS;
	ccr_value = SystemCoreClock / ( 3 * 400E+3);
	/**
	 * si duty == 1
	 * ccr_value = pclk /( 25 * i2c_freq);
	 */
	tempreg |= ccr_value & 0xFFFU;
	I2C1->CCR = tempreg;
	//configurar el TRISE
	//tempreg = pclk / 1000000U + 1;	->100khz
	tempreg = ((SystemCoreClock * 300) /  1000000000U) + 1;
	I2C1->TRISE = tempreg;
	//HABILITAR EL I2C
	I2C1->CR1 |= I2C_CR1_PE;
	return;
}


/**
 * @funcion de envio de datos
 */
void I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t SlaveAddr,uint8_t *pTxbuffer, uint32_t Len){
	volatile uint32_t tmp;
	/*verificar los datos*/
	if(Len <= 0 || pTxbuffer == ((void *)0))
		return;
	/*esperar que linea se libere*/
	while((I2Cx->SR2 & I2C_SR2_BUSY));

	/*generar el start condition*/
	I2Cx->CR1 |= I2C_CR1_START;
	//2. esperar que la condicion de start se haya generado
	while(!(I2Cx->SR1 & I2C_SR1_SB));
	//3. enviar la direccion del esclavo
	SlaveAddr = SlaveAddr <<1 ;				//A7-A1 (R/W)
	SlaveAddr &=~(1U);						//write operation
	I2Cx->DR = SlaveAddr;
	//4. Verificamos que la fase de direccion se complete
	while(!(I2Cx->SR1 & I2C_SR1_ADDR));

	//5. limpiar el flag
	tmp = I2Cx->SR1;
	tmp = I2Cx->SR2;
	(void)tmp;

	//6. enviar los datos
	while(Len > 0){

		while(!(I2Cx->SR1 & I2C_SR1_TXE));
		I2Cx->DR = *pTxbuffer;
		pTxbuffer++;
		Len--;
	}

	//7. esperar hasta que la transmision se haya completado
	while(!(I2Cx->SR1 & I2C_SR1_TXE));
	while(!(I2Cx->SR1 & I2C_SR1_BTF));

	//8. generar la condiciÃ³n de stop
	I2Cx->CR1 |= I2C_CR1_STOP;
	return;
}

/**
 * @brief funcion de recepcion de datos
 */
void I2C_MasterReceiveData(I2C_TypeDef *I2Cx,uint8_t SlaveAddr,uint8_t *pRxbuffer, uint32_t Len){
	volatile int tmp;

	/*verificar los datos*/
	if(Len <= 0 || pRxbuffer == ((void *)0))
		return;
	/*esperar que la linea estÃƒÂ© libre*/
	while((I2Cx->SR2 & I2C_SR2_BUSY));

	//1. generar la condiciÃƒÂ³n de start
	I2Cx->CR1 |= I2C_CR1_START;
	//2. esperar que la condiciÃƒÂ³n de inicio se haya generado
	while(!(I2Cx->SR1 & I2C_SR1_SB));

	//3. enviar la direccion del esclavo
	SlaveAddr = SlaveAddr << 1;
	SlaveAddr |= 1U;			//read operation
	I2Cx->DR = SlaveAddr;
	//4. verificar que la fase de direccion se completÃƒÂ³
	while(!(I2Cx->SR1 & I2C_SR1_ADDR));
	//5. limpiar el flag
	tmp = I2Cx->SR1;
	tmp = I2Cx->SR2;
	(void)tmp;

	/* Enable Acknowledge */
	I2Cx->CR1 |=  I2C_CR1_ACK;
	while(Len>0U){
		if(Len == 1){
			/* Disable Acknowledge */
			I2Cx->CR1 &=~ I2C_CR1_ACK;
			//esperar hasta que RXNE se establesca
			while(!(I2Cx->SR1 & I2C_SR1_RXNE));
			//genera una condicion de parada
			I2Cx->CR1 |= I2C_CR1_STOP;
			//leer el dato
			*pRxbuffer = I2Cx->DR;
			Len--;
		}else{
			//esperar hasta que RXNE se establesca
			while(!(I2Cx->SR1 & I2C_SR1_RXNE));
			*pRxbuffer = I2Cx->DR;
			pRxbuffer++;
			Len--;
		}
	}

	return;
}

/**********************************************************************/

int __io_putchar(int ch){
#if (USE_SW0 == 1)
	ITM_SendChar(ch);
#else
	//todo

#endif
	return ch;
}
