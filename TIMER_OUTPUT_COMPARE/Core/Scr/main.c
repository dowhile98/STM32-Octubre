/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/**
 * Se desea generar se√±ales de salida con el timer3
 * CH1 = 500HZ
 * CH2 = 1KHZ
 * CH3 = 4KHZ
 * CH4 = 16KHZ
 */
#include <stdint.h>
#include "stm32f4xx.h"
/* Private includes ----------------------------------------------------------*/
#include "RCC.h"
#include "Config.h"
#include "USART.h"
#include "Delay.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Private typedef -----------------------------------------------------------*/


/* Private define ------------------------------------------------------------*/


/* Private macro -------------------------------------------------------------*/
#define USE_SWV			0


#define TIM3_CH1		B , 4
#define TIM3_CH2		A , 7
#define TIM3_CH3		B , 0
#define TIM3_CH4		B , 1


#define GET_PULSE(freq)	(16000000/(2*freq*(0 + 1)))
/* Private variables ---------------------------------------------------------*/

USART_Handle_t handle_usart2;

uint8_t rxBuffer[20];
uint8_t byte;
uint8_t i;

uint16_t pulse1 = GET_PULSE(500);
uint16_t pulse2 = GET_PULSE(1000);
uint16_t pulse3 = GET_PULSE(4000);
uint16_t pulse4 = GET_PULSE(16000);
/* Private function prototypes -----------------------------------------------*/


/* Private user code ---------------------------------------------------------*/
/**
 * @brief configura el timer 2 canal 3 como comparacion de salida
 */
static void TIMER3_OC_Config(void);

/* External variables --------------------------------------------------------*/


int main(void)
{
//	PLL_Config();
	/*delay init*/
#if USE_DELAY_US == 1
	delay_Init(SystemCoreClock/1000000);
#else
	delay_Init(SystemCoreClock/1000);
#endif
	/*UART INIT*/
	USART_Init(USART2, 115200);
	handle_usart2.pUSARTx = USART2;
	USART_IRQInterruptConfig(USART2_IRQn, ENABLE);
	USART_ReceiveDataIT(&handle_usart2, &byte, 1);
	/*CONFIGURAR EL TIMER 3	 */
	TIMER3_OC_Config();
	/*LED INIT*/

    /* Loop forever */
	for(;;){


	}
}



/**
 * @brief configura el timer 2 canal 3 como comparacion de salida
 */
static void TIMER3_OC_Config(void){
	/*configuracion de canales*/
	RCC->AHB1ENR |= GPIOX_CLOCK(TIM3_CH1) | GPIOX_CLOCK(TIM3_CH2) | GPIOX_CLOCK(TIM3_CH3) | GPIOX_CLOCK(TIM3_CH4);
	GPIOX_MODER(MODE_ALTER,TIM3_CH1);
	GPIOX_MODER(MODE_ALTER,TIM3_CH2);
	GPIOX_MODER(MODE_ALTER,TIM3_CH3);
	GPIOX_MODER(MODE_ALTER,TIM3_CH4);
	GPIOX_AFR(2,TIM3_CH1);
	GPIOX_AFR(2,TIM3_CH2);
	GPIOX_AFR(2,TIM3_CH3);
	GPIOX_AFR(2,TIM3_CH4);
	/*1. Configura el PSC, ARR para determinar la FREQ del PWM*/
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
	TIM3->PSC = 0;
	TIM3->ARR = 0xFFFF;
	/*Configurar el timer*/
	TIM3->CR1 = 0;
	/*Configurar el registro CCMR2	*/
	TIM3->CCMR1 &=~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S); 	//configura el canal como salida
	TIM3->CCMR1 &=~(TIM_CCMR1_OC1M | TIM_CCMR1_OC2M);
	TIM3->CCMR2 &=~(TIM_CCMR2_CC3S | TIM_CCMR2_CC4S); 	//configura el canal como salida
	TIM3->CCMR2 &=~(TIM_CCMR2_OC3M | TIM_CCMR2_OC4M);
	TIM3->CCMR1 |= 3U<<12 | 3U<<4;						//TOOGLE
	TIM3->CCMR2 |= 3U<<12 | 3U<<4;						//TOOGLE
	TIM3->CCER &=~ (TIM_CCER_CC4P | TIM_CCER_CC3P | TIM_CCER_CC2P | TIM_CCER_CC1P);
	TIM3->CCER |= TIM_CCER_CC4E | TIM_CCER_CC3E | TIM_CCER_CC2E | TIM_CCER_CC1E;				//HABILITAR LA SALIDA DE COMPARACION
	/*habilitar el conteo del timer*/
	TIM3->CCR1 = pulse1;
	TIM3->CCR2 = pulse2;
	TIM3->CCR3 = pulse3;
	TIM3->CCR4 = pulse4;
	/*configurar la interrupcion*/
	TIM3->DIER |= TIM_DIER_CC4IE | TIM_DIER_CC3IE | TIM_DIER_CC2IE | TIM_DIER_CC1IE;
	NVIC_EnableIRQ(TIM3_IRQn);
	NVIC_SetPriority(TIM3_IRQn,2);
	/*SE HABILITA EL CONTEO*/
	TIM3->CR1 |= TIM_CR1_CEN;					//HABILITA EL CONTEO

}

/*****************************************************************************/



/******************************************************************************/
int __io_putchar(int ch){
#if (USE_SWV== 1)
	ITM_SendChar((uint32_t)ch);
#else
	uint8_t c = ch & 0xFF;
	while(!(USART2->SR & USART_SR_TXE));  //espera hasta que usart este listo para transmitir otro byte
	USART2->DR = c;
#endif
	return ch;
}

