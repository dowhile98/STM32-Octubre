/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stm32f4xx.h>
#include <stdio.h>
#include <defines.h>
#include <stdbool.h>
#include <delay_it.h>
/*Defines --------------------------------------*/
#define I2C1_SCL		B , 6
#define I2C1_SDA		B , 7
#define I2C1_ADDR		0x32
#define MPU6050_ADD		0x68
/*Global variables -----------------------------*/
uint8_t data[2];

/*Function prototypes --------------------------*/
/**
 * @brief configura el PLL a 168MHz
 */
void PLL_Config(void);

void I2C1_Init(void);

/**
 * @brief funcion para el envio de datos por I2C
 * @param [I2Cx] 		instancia al i2c usado (I2C1, I2C2 ...)
 * @param [slaveAddr] 	direccion del esclavo
 * @param [pData] 		puntero al buffer a enviar
 * @param [Len] 		cantidad de datos a enviar
 * @param [timeout] 	tiempo maximo de espera para el envio de datos
 */
bool I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout);

/**
 * @brief funcion para la recepcion de datos por I2C
 * @param [I2Cx] 		instancia al i2c usado (I2C1, I2C2 ...)
 * @param [slaveAddr] 	direccion del esclavo
 * @param [pData] 		puntero al buffer donde se va recibir los datos
 * @param [Len] 		cantidad de datos a recibir
 * @param [timeout] 	tiempo maximo de espera para la recepcion de datos de datos
 */
bool I2C_MasterReceiveData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout);

int main(void)
{

	//printf("SYSCLK ANTES DE CONFIGURAR EL PLL: %lu\r\n",SystemCoreClock);
	PLL_Config();
	delay_init_it();
	//->PINOUT I2C1
	RCC->AHB1ENR |= GPIOX_CLOCK(I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SCL);
	GPIOX_MODER(MODE_ALTER, I2C1_SDA);
	GPIOX_AFR(4, I2C1_SCL);
	GPIOX_AFR(4, I2C1_SDA);
	//configura el pin en open drain
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SCL);
	GPIOX_OTYPER(MODE_OT_OD, I2C1_SDA);
	//habilita la resistencia pull pup interna
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SCL);
	GPIOX_PUPDR(MODE_PU_UP, I2C1_SDA);
	I2C1_Init();
	//Prueba de la funcion escrita
//	if(I2C_MasterSendData(I2C1, MPU6050_ADD, data, 1, 1000)){
//		printf("DATOS ENVIADOS CORRECTAMENTE\r\n");
//	}else{
//		printf("error!!!\r\n");
//	}
	uint8_t reg = 0x1A;
	uint8_t datareg[4];
	I2C_MasterSendData(I2C1, MPU6050_ADD, &reg, 1, 200);
	if(I2C_MasterReceiveData(I2C1, MPU6050_ADD, datareg, 4, 2000)){
		printf("datos recibidos\r\n");
	}else{
		printf("error data receive\r\n");
	}
    /* Loop forever */
	for(;;){

	}
}

void PLL_Config(void){
	//1. apagar el pll y esperar que la bandera se limpie
	RCC->CR &=~ (RCC_CR_PLLON);  //RCC->CR &=~ (1<<24);
	while(RCC->CR & RCC_CR_PLLRDY);
	//2. configurar los parametros del pll
	//->Encender el HSE
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY));
	//->HSE como fuente para el PLL
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC;			//->HSE -> PLL
	/**
	 * 8MHZ -> / M <1-2MH> -> * N <50-432MH>
	 * Sysclk = ((8MHz/8) * 336) / 2 = 168MHz
	 */
	//->M
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLM;
	RCC->PLLCFGR |= 8U<<RCC_PLLCFGR_PLLM_Pos;
	//->N
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLN;
	RCC->PLLCFGR |= 336<<RCC_PLLCFGR_PLLN_Pos;
	//->P
	RCC->PLLCFGR &=~ RCC_PLLCFGR_PLLP;
	//3. configurar la latencia de la flash
	FLASH->ACR |= FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN;
	FLASH->ACR |= FLASH_ACR_LATENCY_5WS;
	//->encender el PLL
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//4. seleccionar el PLL como fuente de reloj
	//->Configurar los prescalers de los buses APB1 y ABP2
	//->APB1
	RCC->CFGR &=~ RCC_CFGR_PPRE1;
	RCC->CFGR |= 0x5u<<RCC_CFGR_PPRE1_Pos;
	//->APB2
	RCC->CFGR &=~ RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_2;
	//->Seleccionar el PLL como fuente de reloj del sistema
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));

	SystemCoreClockUpdate();
	return;
}



void I2C1_Init(void){
	uint32_t temp;
	//inicializamos el reloj
	RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
	//configuramos el I2C1
	//1. reiniciar el i2c
	I2C1->CR1 |= I2C_CR1_SWRST;
	I2C1->CR1 &=~ I2C_CR1_SWRST;
	//2. Establecer el bit de control ACK
	I2C1->CR1 |= I2C_CR1_ACK;
	//3. configurar la frecuenciaÂ´
	/**
	 * PCLK1 / 1000000
	 * 42
	 */
	temp = 42;
	I2C1->CR2 = temp & 0x3FU;
	/*4.Establecer la direcion esclava del I2C1*/
	temp = I2C1_ADDR<<1;
	temp |= 1u<<14;
	I2C1->OAR1  = temp;
	/*5. establecer el valor de CCR*/
	/**
	 * SM
	 * CCR = PCLK1 / (2 * 100000)
	 * FM
	 * DUTY = 0
	 * CCR = PCLK1 / (3 * 400000)
	 * CCR = 42E+6 / (3 * 400000)
	 * CCR = 35
	 * DUTY = 1
	 * CCR = PCLK1 / (25 * 400000)
	 */
	temp = 35;
	I2C1->CCR = temp & 0xFFFU;
	I2C1->CCR |= I2C_CCR_FS;
	/*5 configura el TRISE*/
	/**
	 * SM
	 * TRISE = PCLK1 / 1000000 + 1
	 * FS
	 * TRISE = (PCLK1 * 300) / (1000000000U) + 1
	 */
	temp = ((42E+6) * 300 ) /(1000000000U) + 1;
	I2C1->TRISE = temp;
	/*habilitar el I2C1*/
	I2C1->CR1 |= I2C_CR1_PE;
	return;
}

bool I2C_MasterSendData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout){
	volatile uint32_t temp;
	bool state = false;
	uint32_t tickstart = GetTick();
	uint8_t stateuml = 0;
	//verificas el estado de los datos a transmitir
	if(Len <= 0 || pData == ((void *)0)){
		return state;
	}

	/*esperar la linea se libere*/
	while((GetTick() - tickstart)<timeout){
		switch(stateuml){
		case 0: //esperar que la linea se libere
			if(!(I2Cx->SR2 & I2C_SR2_BUSY)){
				stateuml = 1;
			}
			break;
		case 1: //generar la condicion de inicio
			I2Cx->CR1 |= I2C_CR1_START;
			stateuml = 2;
		case 2: //esperar la respuesta al start
			if(I2Cx->SR1 & I2C_SR1_SB){
				stateuml = 3;
			}
			break;
		case 3: //enviar la direccion del esclavo
			slaveAddr = slaveAddr<<1;
			slaveAddr &=~ (1U);			//write
			I2Cx->DR = slaveAddr;
			stateuml = 4;
			break;
		case 4:	//esperar la respuesta del esclavo
			if(I2Cx->SR1 & I2C_SR1_ADDR){
				//limpiar los registros de estado
				temp = I2Cx->SR1;
				temp = I2Cx->SR2;
				(void)temp;
				stateuml = 5;
			}
			break;
		case 5: //enviar los datos
			if(Len>0){
				if(I2Cx->SR1 & I2C_SR1_TXE){
					I2Cx->DR = *pData;
					pData++;
					Len--;
				}
			}else{
				stateuml  = 6;
			}
			break;
		case 6: //esperar que se transmitan los datos y generar la condicion de parada
			while(!(I2Cx->SR1 & I2C_SR1_TXE));
			while(!(I2Cx->SR1 & I2C_SR1_BTF));
			I2Cx->CR1 |= I2C_CR1_STOP;
			state = true;
			break;
		}
		//se verifa la bandera de transmision
		if(state == true){
			break;
		}
	}
	if(state == false){
		I2Cx->CR1 |= I2C_CR1_STOP;
	}
	return state;
}

bool I2C_MasterReceiveData(I2C_TypeDef *I2Cx, uint8_t slaveAddr, uint8_t *pData, uint32_t Len, uint32_t timeout){
	volatile uint32_t temp;
	bool state = false;
	uint32_t tickstart = GetTick();
	uint8_t stateuml = 0;
	//verificas el estado de los datos a transmitir
	if(Len <= 0 || pData == ((void *)0)){
		return state;
	}

	while((GetTick() - tickstart)<timeout){
		switch(stateuml){
		case 0: //esperar que la linea se libere
			if(!(I2Cx->SR2 & I2C_SR2_BUSY)){
				stateuml = 1;
			}
			break;
		case 1: //generar la condicion de inicio
			I2Cx->CR1 |= I2C_CR1_START;
			stateuml = 2;
			break;
		case 2: //esperar la respuesta del start
			if(I2Cx->SR1 & I2C_SR1_SB){
				stateuml = 3;
			}
			break;
		case 3:  //enviar la direccion del esclavo
			slaveAddr = slaveAddr<<1;
			slaveAddr |= (1U);			//read
			I2Cx->DR = slaveAddr;
			stateuml = 4;
			break;
		case 4:	//esperar la respuesta del esclavo
			if(I2Cx->SR1 & I2C_SR1_ADDR){
				//limpiar los registros de estado
				temp = I2Cx->SR1;
				temp = I2Cx->SR2;
				(void)temp;
				/*habilitar el acknowlegde signal*/
				I2Cx->CR1 |= I2C_CR1_ACK;
				stateuml = 5;
			}
			break;
		case 5: //enviar los datos
			if(Len>1){
				//esperar el bit RXNE se ponga 1
				if(I2Cx->SR1 & I2C_SR1_RXNE){
					*pData = I2Cx->DR;
					pData++;
					Len--;
				}
			}else{
				/*deshabilitar el bit ACK*/
				I2Cx->CR1 &=~ I2C_CR1_ACK;
				/*esperamos el dato*/
				if(I2Cx->SR1 & I2C_SR1_RXNE){
					//generar la condicion de parada
					I2Cx->CR1 |= I2C_CR1_STOP;
					//lee el dato
					*pData = I2Cx->DR;
					Len--;
					state = true;
				}
			}
			break;
		}
		//se verifa la bandera de recepcion
		if(state == true){
			break;
		}
	}
	if(state == false){
		I2Cx->CR1 |= I2C_CR1_STOP;
	}
	return state;
}
/**************************************************/

int __io_putchar(int ch){
	ITM_SendChar(ch);
	return ch;
}
