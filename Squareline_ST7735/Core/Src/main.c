/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*Includes ------------------------------------------------------------------*/
#include <stdint.h>
#include "delay_it.h"
#include "ST7735.h"


#include <lvgl.h>
#include "lv_driver.h"
#include "encoder_lv_driver.h"
#include "ui.h"
/*Defines -------------------------------------------------------------------*/
//->SPI3
#define SPI3_SCK    B, 3
#define SPI3_MOSI   B, 5
//->LED
#define LED1		D, 12
//->RCC
#define PLLm		4			// M = 4
#define PLLn		168		// N = 168
#define PLLp		0x0		// P = 2

#define HPRE		0x0		//no divided
#define PPRE1		0x5		//AHB clock divided by 4
#define PPRE2		0x4		//AHB clock divided by 2
/*Global variales -----------------------------------------------------------*/
uint32_t lastupdate;
uint32_t lastLedToggle;
lv_group_t *group;
/*Function prototype---------------------------------------------------------*/
void GPIO_Init(void);
void SPI3_Init(void);
void DMA1_Stream5_init(void);
void SystemClk_Config(void);
void flash_cofig(void);

void lv_example_btn_1(void);

int main(void)
{
    /*Clock config --------------------------------------------------------*/
    flash_cofig();
    SystemClk_Config();                                                     //configura el reloj a 168MHZ
	/*Periphereal init-----------------------------------------------------*/
	delay_init_it();
	GPIO_Init();
	DMA1_Stream5_init();
	SPI3_Init();
	/*Lcd init--------------------------------------------------------------*/
	lv_init();
	lv_port_disp_init();													//tft init
	group = lv_group_create();
  	lv_port_indev_init(group);												//encoder init
  	/*Todo ----------------------------------------------------------------*/
  	lv_group_set_default(group);
	lv_indev_t* cur_drv = NULL;
  	for (;;) {
		  cur_drv = lv_indev_get_next(cur_drv);
		  if (!cur_drv) {
			  break;
		  }
		  if (cur_drv->driver->type == LV_INDEV_TYPE_ENCODER) {
  	            lv_indev_set_group(cur_drv, group);
		  }
  	}
	/*UI init --------------------------------------------------------------*/
  	ui_init();
  	/*User code ------------------------------------------------------------*/
	lastupdate = GetTick();
	lastLedToggle = GetTick();

    /* Loop forever */
	for(;;){
		if((GetTick() - lastupdate)>3){
			lv_task_handler();
			lastupdate = GetTick();
		}
		if((GetTick()-lastLedToggle)>100){
			GPIOX_ODR(LED1) ^= 1;
			lastLedToggle = GetTick();
		}
	}
}
/*Function definition-------------------------------------------------------*/
void GPIO_Init(void){
    RCC->AHB1ENR |= GPIOX_CLOCK(SPI3_SCK) | GPIOX_CLOCK(SPI3_MOSI);
    RCC->AHB1ENR |= GPIOX_CLOCK(A0) | GPIOX_CLOCK(CS) | GPIOX_CLOCK(RESET);
    RCC->AHB1ENR |= GPIOX_CLOCK(LED1) | GPIOX_CLOCK(LED);
	
    //Salida
    GPIOX_MODER(MODE_OUT, A0);
    GPIOX_MODER(MODE_OUT, LED1);
    GPIOX_MODER(MODE_OUT, RESET);
    GPIOX_MODER(MODE_OUT, CS);
    GPIOX_OSPEEDR(MODE_SPD_VHIGH, A0);
    GPIOX_OSPEEDR(MODE_SPD_VHIGH, RESET);
    GPIOX_OSPEEDR(MODE_SPD_VHIGH, CS);
	GPIOX_MODER(MODE_OUT, LED);
    //SPI3
    GPIOX_MODER(MODE_ALTER, SPI3_SCK);
    GPIOX_MODER(MODE_ALTER, SPI3_MOSI);
    GPIOX_AFR(6, SPI3_SCK);
    GPIOX_AFR(6, SPI3_MOSI);
    GPIOX_OSPEEDR(MODE_SPD_VHIGH, SPI3_MOSI);
    GPIOX_OSPEEDR(MODE_SPD_VHIGH, SPI3_SCK);
    return;
}
void SPI3_Init(void){
    //se habilita el reloj
    RCC->APB1ENR |= RCC_APB1ENR_SPI3EN;
    //1. Configurar el baudrate
	SPI3->CR1 &=~ SPI_CR1_BR;			//Fpclk / 2 = 21MHz
	//2. configurar la poliridad y la fasse del reloj
	//CPOL
	SPI3->CR1 &=~ SPI_CR1_CPOL;			//CPOL = 0
	//CPHA
	SPI3->CR1 &=~ SPI_CR1_CPHA;			//CPHA = 0
	/*3. seleccionar la longitud de la trama*/
	SPI3->CR1 &=~ SPI_CR1_DFF;			//8-bit
	/*4. configurar LSB o MSB first*/
	SPI3->CR1 &=~ SPI_CR1_LSBFIRST;		//MSB FIRST
	/*5. configura el mamejo del pin NSS*/
	SPI3->CR1 |= SPI_CR1_SSM;			//software managment
	SPI3->CR1 |= SPI_CR1_SSI;
	/*6 configurar el modo TI si es que fuera necesario	 */

	/*7. habilita el modo maestro*/
	SPI3->CR1 |= SPI_CR1_MSTR;			//habilita el modo maestro
	/*8. habilitar el spi*/
	SPI3->CR1 |= SPI_CR1_SPE;			//habilita el spi para tx y rx
}
void DMA1_Stream5_init(void){
    //se habilita el reloj
    RCC->AHB1ENR |= RCC_AHB1ENR_DMA1EN;
    //se habilita la interrupcion para el stream5
    NVIC_EnableIRQ(DMA1_Stream5_IRQn);
    //se selecciona el canal
    DMA1_Stream5->CR &=~ DMA_SxCR_CHSEL;            //channel 0
    //se establece la direccion
    DMA1_Stream5->CR &=~ DMA_SxCR_DIR;
    DMA1_Stream5->CR |= DMA_SxCR_DIR_0;
    //prioridad alta
    DMA1_Stream5->CR |= DMA_SxCR_PL;                //prioridad alta
    //modo normal
    DMA1_Stream5->CR &=~ DMA_SxCR_CIRC;
    DMA1_Stream5->CR &=~ DMA_SxCR_PFCTRL;
    //increment
    DMA1_Stream5->CR |= DMA_SxCR_MINC;
    DMA1_Stream5->CR &=~ DMA_SxCR_PINC;
    //tamaÃ±o de datos
    DMA1_Stream5->CR &=~ DMA_SxCR_PSIZE;
    DMA1_Stream5->CR &=~ DMA_SxCR_PSIZE;
    DMA1_Stream5->FCR &=~ DMA_SxFCR_DMDIS;
    return;
}
void SystemClk_Config(void){

	/*1. habilitamos las fuentes de reloj necesarios*/
	RCC->CR |= RCC_CR_HSEON;			//1<<16
	while(!(RCC->CR &  RCC_CR_HSERDY));
	/*2. configuramos la pll*/
	RCC->PLLCFGR = 0x0000000;			//reset
	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSE;
	RCC->PLLCFGR |= PLLp<<16 | PLLn<<6 | PLLm<<0;
	RCC->CR |= RCC_CR_PLLON;			//1<<24
	while(!(RCC->CR & RCC_CR_HSERDY));	//wait
	/*3. elegir la fuente del sysclk*/
	RCC->CFGR = 0x00000000;				//reset
	RCC->CFGR |= PPRE2<<13 | PPRE1<<10 | HPRE<<4;

	/*5 WS (6 CPU cycles) 150 <HCLK = 180*/
	FLASH->ACR &=~(uint32_t)(0x7<<0);
	FLASH->ACR |= 0x5<<0;				//Five wait states

	RCC->CFGR |= 0x2;					//PLL selected as system clock
	while(!(RCC->CFGR & RCC_CFGR_SWS_PLL));//se espera hasta que se estabilice
	SystemCoreClockUpdate();
    return;
}

void flash_cofig(void){
	FLASH->ACR |= 1<<9;					//1: Instruction cache is enabled
	FLASH->ACR |= 1<<10;				//1: Data cache is enabled
	FLASH->ACR |= 1<<8;					//1: Prefetch is enabled
	//SE HABILITAN ALGUNOS CLOCK
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
}
